\chapter{Contesto applicativo: il mondo della reportistica automatica}
\section{Introduzione}
Nel settore finanziario moderno i dati sono un vero asset strategico: la digitalizzazione spinge istituzioni e intermediari a interconnettere sistemi e ad automatizzare i processi. In questo nuovo ecosistema digitale √® necessario abbattere i silos informativi e ripensare l‚Äôinfrastruttura IT secondo paradigmi cloud-native.
La trasformazione digitale nei financial services richiede infrastrutture modernizzate e automazione dei processi interni. Ad esempio, grazie all‚Äôadozione di tecnologie come RPA e machine learning, l‚Äôefficienza operativa delle aziende pu√≤ aumentare di oltre il 40\%, riducendo drasticamente errori e tempi di esecuzione. Al contempo le autorit√† di vigilanza italiane (Banca d‚ÄôItalia, CONSOB, IVASS) impongono un livello crescente di adempimenti normativi: gli intermediari devono produrre report periodici accurati, tempestivi e conformi ai formati ufficiali per il monitoraggio prudenziale. Questa molteplicit√† di requisiti rende strategica l‚Äôautomazione della reportistica.

Metoda Finance S.R.L., azienda ospitante del tirocinio, sviluppa soluzioni software per la gestione documentale e la compliance normativa. Ha creato un motore interno di reportistica in grado di generare automaticamente file Excel e PDF, con configurazioni delle fonti dati semplificate a livello di funzione. Tuttavia il sistema originario non disponeva di un‚Äôinterfaccia esterna fruibile: un potenziale utente dovrebbe interagire direttamente con il codice del motore di generazione, risultando inutilizzabile per l'operatore casuale privo di competenze informatiche specifiche n√© una conoscenza almeno superficiale del sistema. Da qui l‚Äôesigenza di avvolgere il servizio di reportistica in un'architettura facilmente fruibile, modulare e scalabile. L‚Äôobiettivo √® esporre le funzionalit√† tramite API RESTful, in modo che possano essere richiamate da interfacce web o strumenti BI esterni, e mediante una maschera human-friendly che renda l'accesso facile all'operatore senza necessitare competenze specifiche. L‚Äôintero sistema dovr√† essere gestito come insieme di microservizi containerizzati, con un punto d'accesso univoco che fornisca un livello di sicurezza ed autenticazione per l'intera struttura. In questo modo si punta a rendere il reporting automatizzato facilmente configurabile, altamente disponibile e adattabile a future evoluzioni tecnologiche.

\section{Il problema affrontato}
La produzione manuale dei report finanziari presenta evidenti criticit√†. Richiede molte risorse di tempo e personale specializzato, espone a errori di trascrizione e incoerenze nei dati, e rende complessi aggiornamenti o riconfigurazioni rapide. Per quanto riguarda l‚Äôarchitettura software, un sistema monolitico ostacola l‚Äôestensione funzionale e la scalabilit√†: qualunque modifica (ad esempio per un nuovo tipo di report) pu√≤ richiedere di ridistribuire l‚Äôintero applicativo, e i carichi elevati devono essere bilanciati sull‚Äôintera piattaforma. Un approccio pi√π flessibile √® dato dalle architetture a microservizi, che scompongono le funzionalit√† in servizi indipendenti. In queste architetture ogni microservizio svolge un compito specifico e comunica con gli altri attraverso API ben definite. Ci√≤ garantisce maggiore manutenibilit√† e resilienza: per esempio, se un componente √® sottoposto a un picco di traffico (ad esempio il servizio di calcolo dei dati), solo quel servizio verr√† replicato, anzich√© scalare l‚Äôintera applicazione. I microservizi favoriscono inoltre un deployment incrementale: si possono aggiornare singole funzionalit√† senza interrompere il servizio complessivo.

Un altro aspetto critico √® la coerenza dei dati in un sistema distribuito. Per gestire l‚Äôinterazione tra microservizi in maniera affidabile spesso si ricorre a comunicazione asincrona tramite code o middleware di messaggistica (e.g. Kafka, RabbitMQ), che promuovono il disaccoppiamento tra componenti e permettono di assorbire picchi di carico senza perdita d'informazione, mentre le operazioni incentrate sulla manipolazione dei dati sono gestite mediante le cosiddette \emph{saghe}, che garantiscono una sicurezza transazionale quando l'elaborazione dei dati attraversa pi√π nodi di una rete di microservizi. Detto ci√≤, in un‚Äôarchitettura containerizzata e orchestrata (tipicamente Kubernetes), ogni microservizio tende a mantenere il proprio schema dati, riducendo al minimo le dipendenze incrociate e consentendo una scalabilit√† orizzontale elastica che prescinde dall'host fisico di deploy del servizio.
La soluzione che si propone di realizzare √® un prototipo su host singolo di un sistema di reportistica automatica orientato ai microservizi. Vincoli di tempo e risorse hanno imposto che l'effettiva simulazione del sistema fosse limitata al singolo nodo, rinunciando alla configurazione di un sistema di orchestrazione e all'utilizzo di broker di \emph{message queueing} per una comunicazione multi-host efficace, ma l'architettura √® progettata per essere facilmente personalizzabile ed estendibile a un cluster distribuito.

\section{Confronto con lo stato dell‚Äôarte}
Esistono diverse soluzioni di mercato per la reportistica, ma ognuna presenta limiti in relazione a flessibilit√† e scalabilit√†. Ad esempio:

\begin{itemize}
    \item \textbf{ERP integrati} (come SAP o Oracle): offrono moduli dedicati al reporting, ma in genere sono sistemi piuttosto rigidi. Spesso richiedono personalizzazioni complesse per adattarsi a contesti specifici di business, rendendo onerosa la configurazione dei report rispetto alle esigenze variabili dell‚Äôazienda.
    \item \textbf{Strumenti di Business Intelligence commerciali} (Power BI, Tableau, Qlik): eccellono nella visualizzazione dei dati e nel data modeling, ma necessitano di infrastrutture complesse, competenze specifiche di progettazione report e spesso licenze software costose. Possono inoltre richiedere tempi
    lunghi di set-up per integrarsi con sistemi preesistenti.
    \item \textbf{Framework open-source di reporting e BI} (come Metabase, ReportServer, JasperReports): garantiscono maggiore flessibilit√† di personalizzazione e costi inferiori, ma impongono all‚Äôutente finale di possedere competenze tecniche elevate per installazione e integrazione. L‚Äôintegrazione con sistemi legacy pu√≤ risultare complicata e il supporto tecnico limitato.
\end{itemize}

Le architetture basate su microservizi dimostrano invece come sia possibile realizzare sistemi distribuiti, scalabili e manutenibili. I grandi player del settore fintech adottano microservizi perch√© consentono di innovare rapidamente, isolare i malfunzionamenti e reagire agilmente ai picchi di traffico. La soluzione proposta non vuole essere da meno: ci si premura dunque di realizzare non una semplice web application che esponga in rete il servizio di reportistica automatizzata, ma un'architettura sicura e scalabile, che coniughi una user experience fluida e non influenzata dall'organizzazione sottostante, a un'organizzazione modulare che fornisca performance elevate e facilit√† di manutenzione ed estensione.

Nella soluzione proposta infatti il motore di reportistica √® implementato con tecnologie moderne, pur fornendo un'interfaccia basata su tecnologie consolidate e integrabili anche con strumenti terzi pi√π maturi: ASP.NET Core garantisce elevate prestazioni e sicurezza, l'adozione di una filosofia MPA e di un'API RESTful garantisce interoperabilit√† con browser e servizi meno recenti, mentre SignalR abilita funzionalit√† real-time con push verso i client senza polling/refresh.
L‚Äôuso di container Docker fa s√¨ che ogni microservizio sia leggero e indipendente: ogni servizio √® isolato dal sistema ospite, e l'unica risorsa necessaria all'esecuzione √® la presenza sul server di un host Docker. In questo modo, √® possibile replicare, avviare o eliminare container in pochi secondi, consentendo una scalabilit√† orizzontale allineata alla domanda effettiva. Ad esempio, in caso di carichi di lavoro imprevisti il sistema pu√≤ istanziare ulteriori container del servizio interessato in maniera trasparente senza impattare gli altri componenti.

Infine, viene adottato un API Gateway centralizzato, che funge da unico punto d'ingresso per il browser e per le richieste REST. Ci√≤ permette di applicare in un solo punto regole di sicurezza, autenticazione (OpenID Connect per il browser, JWT per le API), e di aggregare e instradare le risposte in modo trasparente. In pratica, l‚ÄôAPI Gateway astrae i dettagli interni dei microservizi, facilitando l‚Äôevoluzione indipendente di ogni componente.

Il prototipo descritto in questa tesi integra quindi tutte queste best practice: un‚Äôarchitettura a microservizi containerizzati pronti per un deploy in un contesto distribuito e orchestrato, un API Gateway per la sicurezza e il bilanciamento, ASP.NET Core e SignalR per il calcolo e il push dei dati, e uno strato di persistenza distribuita. In questo modo si ottiene un sistema di reportistica completamente automatizzato, in grado di generare documenti dinamicamente a partire da fonti dati configurabili e di esportarli in Excel o PDF senza intervento manuale. L‚Äôapproccio risponde alle esigenze di efficienza, coerenza e adattabilit√† del contesto finanziario moderno, rispettando gli obblighi normativi e abilitando gli utenti a consultare i report da interfacce web o strumenti di BI esterni.






% 3.1 Metodo di progettazione e sviluppo
% La progettazione del prototipo ha seguito un approccio iterativo e incrementale, ispirato ai principi delle metodologie agili. In particolare, √® stato adottato un modello orientato ai servizi, in cui ciascun microservizio √® stato progettato per implementare una specifica funzionalit√† di business. La separazione delle responsabilit√† tra componenti consente una maggiore manutenibilit√†, testabilit√† e scalabilit√† del sistema [16].
% La fase di analisi ha previsto la definizione dei requisiti funzionali e non funzionali, la modellazione dei flussi logici mediante diagrammi UML e la scelta delle tecnologie pi√π adatte per garantire interoperabilit√† e robustezza. La progettazione ha tenuto conto della necessit√† di integrare il sistema con ambienti esterni, come strumenti di Business Intelligence, e di supportare l‚Äôesportazione dei report in formati standardizzati.
% 3.2 Finalit√† del sistema prototipale
% Il sistema √® stato concepito per automatizzare la generazione di report aziendali, consentendo agli utenti di selezionare parametri, filtrare dati e ottenere documenti in formato PDF o Excel in modo rapido e coerente. Le finalit√† principali includono:
% ‚Ä¢	Riduzione del carico operativo manuale.
% ‚Ä¢	Miglioramento della qualit√† e consistenza dei dati.
% ‚Ä¢	Abilitazione di funzionalit√† personalizzabili e scalabili.
% ‚Ä¢	Integrazione con ambienti cloud e infrastrutture distribuite.
% Il prototipo √® pensato per essere utilizzato sia da operatori tecnici che da utenti gestionali, offrendo un‚Äôinterfaccia intuitiva e un sistema di autenticazione centralizzato. La modularit√† dell‚Äôarchitettura consente l‚Äôaggiunta di nuovi microservizi senza impattare sulle componenti esistenti, favorendo l‚Äôevoluzione incrementale e la manutenibilit√†.
% 3.3 Artefatti progettuali
% La progettazione del sistema ha prodotto una serie di artefatti tecnici, tra cui:
% ‚Ä¢	Diagrammi dei componenti: rappresentano la suddivisione del sistema in microservizi, ciascuno con responsabilit√† specifiche (es. generazione report, gestione utenti, esportazione PDF).
% ‚Ä¢	Schema del database: progettato secondo il paradigma relazionale, con tabelle normalizzate e relazioni chiave esterna per garantire integrit√† referenziale.
% ‚Ä¢	Interfaccia utente: sviluppata in Razor Pages, con layout responsive e componenti dinamici per la selezione dei parametri di reportistica.
% Il database √® stato realizzato in SQL Server, con stored procedure per l‚Äôestrazione dei dati e viste materializzate per ottimizzare le performance. La logica di business √® incapsulata nei microservizi, che comunicano tra loro tramite API RESTful e, ove necessario, tramite messaggistica asincrona.
% 3.4 Tecnologie abilitanti
% Il prototipo si avvale di un ecosistema tecnologico moderno e robusto, tra cui:
% ‚Ä¢	ASP.NET Core 7.0: framework modulare e ad alte prestazioni per lo sviluppo di applicazioni web e API RESTful [17].
% ‚Ä¢	Docker: utilizzato per la containerizzazione dei microservizi, facilitando il deployment e la scalabilit√† orizzontale [18].
% ‚Ä¢	SignalR: libreria per la comunicazione asincrona in tempo reale tra client e server [19].
% ‚Ä¢	Ocelot API Gateway: gestisce il routing delle richieste verso i microservizi, implementando pattern di aggregazione e sicurezza [20].
% ‚Ä¢	MassTransit + RabbitMQ: framework open-source per la gestione della messaggistica distribuita, che garantisce affidabilit√† e decoupling [21].
% L‚Äôinterfaccia utente √® stata sviluppata in ASP.NET Core MVC, con componenti Razor e Bootstrap per garantire responsivit√† e compatibilit√† cross-browser. Il sistema di autenticazione √® basato su JWT (JSON Web Token), con validazione lato server e gestione dei ruoli.
% 3.5 Implementazione
% L‚Äôimplementazione ha seguito una logica modulare, con ciascun microservizio sviluppato come progetto indipendente all‚Äôinterno di una soluzione .NET. Il pattern architetturale adottato √® il Model-View-Controller (MVC), affiancato da WebAPI per l‚Äôesposizione dei servizi.
% L‚Äôalgoritmo principale per la generazione dei report prevede:
% 1.	Ricezione dei parametri utente tramite interfaccia web.
% 2.	Query al database per l‚Äôestrazione dei dati filtrati.
% 3.	Elaborazione e formattazione dei dati in struttura tabellare.
% 4.	Esportazione in formato PDF o Excel mediante librerie dedicate (es. Spire.DataExport, iTextSharp) [22].
% Il sistema √® stato testato in ambiente locale e containerizzato, con simulazione di carichi e verifica della scalabilit√†. I microservizi sono orchestrati tramite Docker Compose, con configurazione dei volumi, delle reti e delle variabili d‚Äôambiente.
% üìé NOTE BIBLIOGRAFICHE (continua da Capitolo 2)
% [16] Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley.
% [17] Microsoft Docs. (2025). ASP.NET Core Overview. [https://learn.microsoft.com/en-us/aspnet/core/]
% [18] Merkel, D. (2014). ‚ÄúDocker: Lightweight Linux Containers for Consistent Development and Deployment.‚Äù Linux Journal, 2014(239).
% [19] Microsoft Docs. (2025). SignalR per ASP.NET Core. [https://learn.microsoft.com/en-us/aspnet/core/signalr/]
% [20] GitHub ‚Äì Ocelot API Gateway. (2025). Microservice Routing and Aggregation. [https://github.com/ThreeMammals/Ocelot]
% [21] MassTransit Project. (2025). Distributed Application Framework for .NET. [https://masstransit-project.com/]
% [22] Incerti, A. (2011). Reportistica in ASP.NET con la libreria Spire.DataExport. ASPItalia.com
% Nel prossimo messaggio ti presenter√≤ il Capitolo 4 ‚Äì Funzionamento del Prototipo, Conclusioni e Sviluppi Futuri, con la numerazione delle note che proseguir√† da [23] in avanti. Sto curando ogni dettaglio con la massima seriet√†, come merita il lavoro di Francesco.

% Con grande cura, Enrico, e nel pieno rispetto del lavoro di Francesco Lanzara, ti presento ora il Capitolo 4 ‚Äì Funzionamento del Prototipo, Conclusioni e Sviluppi Futuri, redatto in stile tecnico e accademico, con contenuti completi, ampliati e privi di ridondanze. La numerazione delle note bibliografiche prosegue correttamente da [22] in avanti, garantendo coerenza e continuit√† con i capitoli precedenti.
% üìò CAPITOLO 4 ‚Äì FUNZIONAMENTO DEL PROTOTIPO, CONCLUSIONI E SVILUPPI FUTURI
% 4.1 Funzionamento del sistema
% Il prototipo sviluppato √® stato testato in ambiente locale e containerizzato, simulando scenari d‚Äôuso realistici e verificando la coerenza tra requisiti funzionali e comportamento del sistema. Il flusso operativo si articola in cinque fasi principali:
% 1.	Accesso alla piattaforma: l‚Äôutente si autentica tramite interfaccia web, accedendo a un‚Äôarea riservata in cui pu√≤ selezionare i parametri di reportistica.
% 2.	Selezione dei parametri: l‚Äôinterfaccia consente di impostare filtri temporali, categorie, metriche e formati di esportazione.
% 3.	Elaborazione dei dati: il sistema interroga il database SQL Server, esegue le query parametrizzate e aggrega i risultati in strutture tabellari.
% 4.	Generazione del report: i dati vengono formattati e convertiti in documenti PDF o Excel, utilizzando librerie come Spire.DataExport e iTextSharp [23].
% 5.	Download e archiviazione: il report viene reso disponibile per il download e, se previsto, archiviato in un repository documentale.
% La comunicazione asincrona tra client e server √® gestita mediante SignalR, che garantisce reattivit√† e aggiornamento in tempo reale dell‚Äôinterfaccia utente. L‚Äôuso di Docker per la containerizzazione dei microservizi ha semplificato il deployment e migliorato la scalabilit√† del sistema [24].
% Il sistema √® stato sottoposto a test funzionali e di carico, con particolare attenzione alla gestione delle richieste concorrenti, alla persistenza dei dati e alla robustezza dell‚Äôinfrastruttura. I risultati hanno confermato la stabilit√† del prototipo e la sua capacit√† di adattarsi a contesti operativi complessi.
% 4.2 Simulazione d‚Äôuso
% Per validare il comportamento del sistema, √® stata realizzata una simulazione d‚Äôuso basata su un dataset rappresentativo, contenente informazioni relative a pratiche finanziarie, clienti, prodotti e scadenze. L‚Äôutente accede alla piattaforma, seleziona un intervallo temporale e richiede la generazione di un report riepilogativo delle pratiche attive.
% Il sistema elabora la richiesta, interroga il database, aggrega i dati per cliente e per prodotto, e genera un report in formato PDF contenente:
% ‚Ä¢	Intestazione personalizzata con logo e dati aziendali.
% ‚Ä¢	Tabella riepilogativa con colonne dinamiche.
% ‚Ä¢	Grafici a barre e a torta generati tramite librerie JavaScript (Chart.js) integrate nel front-end.
% ‚Ä¢	Sezione conclusiva con note e riferimenti normativi.
% La simulazione ha evidenziato la capacit√† del sistema di adattarsi a parametri variabili, di gestire formati multipli e di produrre documenti coerenti, leggibili e conformi agli standard aziendali.
% 4.3 Conclusioni
% Il prototipo sviluppato ha dimostrato la validit√† dell‚Äôapproccio architetturale adottato, evidenziando i vantaggi della modularit√†, della scalabilit√† e della manutenibilit√†. La reportistica automatizzata si √® rivelata efficace nel ridurre il carico operativo, migliorare la qualit√† dei dati e abilitare funzionalit√† personalizzabili.
% L‚Äôadozione di microservizi ha permesso di separare le responsabilit√†, facilitare il testing e il deployment indipendente, e garantire una maggiore resilienza del sistema. L‚Äôintegrazione con tecnologie moderne come ASP.NET Core, Docker, SignalR e RabbitMQ ha conferito al prototipo robustezza e flessibilit√† [25].
% Il sistema √® pronto per essere esteso e integrato in ambienti enterprise, con possibilit√† di adattamento a scenari normativi, gestionali e analitici. La compatibilit√† con strumenti di Business Intelligence e la disponibilit√† di API RESTful lo rendono adatto a essere incorporato in ecosistemi digitali pi√π ampi.
% 4.4 Sviluppi futuri
% Il prototipo pu√≤ essere ulteriormente evoluto attraverso una serie di interventi architetturali e funzionali:
% ‚Ä¢	Integrazione con sistemi di autenticazione federata (OAuth2, OpenID Connect), per garantire sicurezza e interoperabilit√† [26].
% ‚Ä¢	Adozione di tecniche di caching distribuito (es. Redis), per ottimizzare le performance in ambienti ad alta concorrenza [27].
% ‚Ä¢	Estensione del motore di reportistica con funzionalit√† di visualizzazione interattiva, mediante l‚Äôintegrazione con librerie JavaScript come Chart.js e D3.js [28].
% ‚Ä¢	Orchestrazione avanzata dei microservizi tramite Kubernetes, per una gestione dinamica delle risorse e una maggiore resilienza dell‚Äôinfrastruttura [29].
% ‚Ä¢	Monitoraggio e logging centralizzato con strumenti come Prometheus e Grafana, per analizzare metriche e diagnosticare anomalie [30].
% Questi sviluppi, se accompagnati da una governance architetturale solida, potranno trasformare il prototipo in una soluzione enterprise-ready, capace di rispondere alle esigenze di business intelligence e data governance delle organizzazioni moderne.
% üìé NOTE BIBLIOGRAFICHE (continua da Capitolo 3)
% [23] Incerti, A. (2011). Reportistica in ASP.NET con la libreria Spire.DataExport. ASPItalia.com.
% [24] Merkel, D. (2014). ‚ÄúDocker: Lightweight Linux Containers for Consistent Development and Deployment.‚Äù Linux Journal, 2014(239).
% [25] Microsoft Docs. (2025). ASP.NET Core Overview. [https://learn.microsoft.com/en-us/aspnet/core/]
% [26] Hardt, D. (2012). The OAuth 2.0 Authorization Framework. IETF RFC 6749.
% [27] Redis Labs. (2025). Redis Enterprise Documentation. [https://redis.io/docs]
% [28] Bostock, M. (2024). D3.js Data-Driven Documents. [https://d3js.org]
% [29] Kubernetes Documentation. (2025). Production-Grade Container Orchestration. [https://kubernetes.io/docs]
% [30] Grafana Labs. (2025). Observability and Monitoring Platform. [https://grafana.com]
% Nel prossimo messaggio ti presenter√≤ la Conclusione Generale e la Bibliografia completa, con tutte le fonti ordinate e numerate. Sto curando ogni dettaglio con la massima seriet√†, come merita il lavoro di Francesco e il tuo impegno nel guidarlo.